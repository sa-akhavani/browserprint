const fs = require('fs')
const csv = require('csvtojson');

const datasetDir = '../../dataset/';

// let keys = new Set();

async function simplifyCveFile(vulnarabilityDataset) {
    let cveList = [];
    for (let cve of vulnarabilityDataset.CVE_Items) {
        if (cve.cve) {
            let newCve = {
                description: cve.cve.description,
                configurations: cve.configurations
            }
            cveList.push(newCve);
        }
    }
    return cveList;
}

async function parseNode(node, affectedVersions) {
    if (node.operator == 'OR' && node.cpe_match) {
        for (let cpe of node.cpe_match) {
            if (cpe.vulnerable == false) {
                continue;
            }
            if (cpe.cpe23Uri.includes('google:chrome:'))
                affectedVersions.push(cpe)
            if (cpe.cpe23Uri.includes('mozilla:firefox:'))
                affectedVersions.push(cpe)
        }
    } else if (node.operator == 'AND') {
        if (node.children) {
            for (let v of node.children) {
                affectedVersions = await parseNode(v, affectedVersions)
            }
        }
    } else {
        // console.log('NOT OR NOR AND!!!!!!!!!!!!!!')
    }
    return affectedVersions
}

async function cveParser(cveList) {
    let vulnarabilityList = []
    for (let cve of cveList) {
        let affectedVersions = []
        for (let node of cve.configurations.nodes) {
            affectedVersions = await parseNode(node, affectedVersions)
        }


        if (affectedVersions.length == 0)
            continue;

        let extractedData = {
            affectedVersions: affectedVersions,
            description: cve.description.description_data[0].value,
            // publishDate: cve.publishedDate,
            // severity: cve.impact.baseMetricV2.severity
        }
        vulnarabilityList.push(extractedData);
    }

    return vulnarabilityList;
}

async function versionCompare(v1, v2) {
    v1parts = v1.split('.');
    v2parts = v2.split('.');
    while (v1parts.length < v2parts.length) v1parts.push("0");
    while (v2parts.length < v1parts.length) v2parts.push("0");
    v1parts = v1parts.map(Number);
    v2parts = v2parts.map(Number);
    for (var i = 0; i < v1parts.length; ++i) {
        if (v2parts.length == i) {
            return 1;
        }

        if (v1parts[i] == v2parts[i]) {
            continue;
        }
        else if (v1parts[i] > v2parts[i]) {
            return 1;
        }
        else {
            return -1;
        }
    }
    return 0
}

async function browserExistInCondition(browserVersion, cve) {
    let result
    if (cve.versionEndIncluding) {
        res = await versionCompare(browserVersion, cve.versionEndIncluding)
        if (res == 0 || res == -1)
            return true;
        else
            return false
    } else if (cve.versionEndExcluding) {
        res = await versionCompare(browserVersion, cve.versionEndExcluding)
        if (res == -1)
            return true;
        else
            return false        
    } else if (cve.versionStartIncluding) {
        res = await versionCompare(browserVersion, cve.versionStartIncluding)
        if (res == 0 || res == 1)
            return true;
        else
            return false        
    } else if (cve.versionStartExcluding) {
        res = await versionCompare(browserVersion, cve.versionStartExcluding)
        if (res == -1)
            return true;
        else
            return false        
    } else {
        //todo there were very few cves that were in this part
        // console.log('NOTHING!!!!')
        return false
    }
}

async function isVulnerable(browser, version, cve) {
    for (let v of cve.affectedVersions) {
        if (browser == 'chrome' && v.cpe23Uri.includes(':chrome:')) {
            return await browserExistInCondition(version, v)
        } else if (browser == 'firefox' && v.cpe23Uri.includes(':firefox:')) {
            return await browserExistInCondition(version, v)
        }
    }
}

async function findVulnarabilitiesPerBrowser(browserData, cveList) {
    for (let cve of cveList) {
        for (let browser of browserData) {
            if (await isVulnerable(browser.browser, browser.version, cve)) {
                browser.numOfVulnerabilities++;
            }
        }
    }
    return browserData;
}

async function generateVulnerabilityReport(browserData, vulnerabilityReportFile) {
    let fileContent = JSON.parse(vulnerabilityReportFile);
    let cveData = await simplifyCveFile(fileContent);
    let parsedCveList = await cveParser(cveData);
    browserData = await findVulnarabilitiesPerBrowser(browserData, parsedCveList);
    return browserData;
}

async function main() {
    browserData = await csv()
        .fromFile(datasetDir + 'browser-data.csv')
    for (let browser of browserData) {
        browser.numOfVulnerabilities = 0;
    }
    let vulnerabilityReportFile = fs.readFileSync(datasetDir + 'nvdcve-1.1-2020.json');
    browserData = await generateVulnerabilityReport(browserData, vulnerabilityReportFile);

    vulnerabilityReportFile = fs.readFileSync(datasetDir + 'nvdcve-1.1-2019.json');
    browserData = await generateVulnerabilityReport(browserData, vulnerabilityReportFile);

    vulnerabilityReportFile = fs.readFileSync(datasetDir + 'nvdcve-1.1-2018.json');
    browserData = await generateVulnerabilityReport(browserData, vulnerabilityReportFile);

    vulnerabilityReportFile = fs.readFileSync(datasetDir + 'nvdcve-1.1-2017.json');
    browserData = await generateVulnerabilityReport(browserData, vulnerabilityReportFile);

    vulnerabilityReportFile = fs.readFileSync(datasetDir + 'nvdcve-1.1-2016.json');
    browserData = await generateVulnerabilityReport(browserData, vulnerabilityReportFile);
    

    console.log('browser, version, releaseDate, numOfVulnerabilities')
    for (let index = browserData.length-1; index >=0; index--) {
        browser = browserData[index]
        console.log(`${browser.browser}, ${browser.version}, ${browser.releaseDate}, ${browser.numOfVulnerabilities}`)
        
    }
}

main();